import { NextResponse } from 'next/server';
import { auth } from '@/auth';
import prisma from '@/lib/db';
import { calculateSM2, mapPerformanceToQuality } from '@/lib/sm2-algorithm';

export async function GET(request: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const wordId = searchParams.get('wordId');

  if (!wordId) {
    return NextResponse.json({ message: 'Word ID is required' }, { status: 400 });
  }

  try {
    const userProgress = await prisma.userProgress.findFirst({
      where: {
        userId: parseInt(session.user.id),
        wordId: parseInt(wordId),
      },
    });

    if (!userProgress) {
      return NextResponse.json({ message: 'Progress not found' }, { status: 404 });
    }

    return NextResponse.json(userProgress);
  } catch (error) {
    console.error('Error fetching user progress:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  const session = await auth();

  if (!session?.user?.id) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    console.log('Progress API received:', body);

    const { wordId, isCorrect, responseTime, sessionWordAttempts } = body;

    if (!wordId || typeof isCorrect === 'undefined') {
      console.log('Missing required fields:', { wordId, isCorrect });
      return NextResponse.json({ message: 'Word ID and correctness are required' }, { status: 400 });
    }
    const userId = parseInt(session.user.id);
    const wordIdNum = parseInt(wordId);

    console.log('Processing progress for:', { userId, wordIdNum });

    // Get or create user progress using findFirst to get current state
    const userProgress = await prisma.userProgress.findFirst({
      where: {
        userId: userId,
        wordId: wordIdNum,
      },
    });

    console.log('Found existing progress:', userProgress ? 'YES' : 'NO');

    // Calculate SM-2 quality rating based on performance
    const quality = mapPerformanceToQuality(isCorrect, responseTime, sessionWordAttempts);
    console.log('SM-2 inputs:', { quality, isCorrect, responseTime, sessionWordAttempts });

    // Get default values for new progress records
    const defaultProgress = {
      correctCount: 0,
      incorrectCount: 0,
      consecutiveCorrect: 0,
      timesSeen: 0,
      isManuallyLearned: false,
      easinessFactor: 2.5,
      interval: 1,
      repetition: 0,
      nextReviewDate: new Date(),
      quality: null,
    };

    // Use existing values or defaults
    const currentValues = userProgress || defaultProgress;

    // Apply SM-2 algorithm
    const sm2Result = calculateSM2({
      quality,
      easinessFactor: currentValues.easinessFactor,
      interval: currentValues.interval,
      repetition: currentValues.repetition,
    });

    console.log('SM-2 result:', sm2Result);

    // Ensure the nextReviewDate is a valid Date object
    const nextReviewDate = new Date(sm2Result.nextReviewDate);

    if (isNaN(nextReviewDate.getTime())) {
      console.error('Invalid date created:', sm2Result.nextReviewDate);
      throw new Error('Invalid nextReviewDate generated by SM-2 algorithm');
    }

    // Prepare the data for upsert
    const progressData = {
      timesSeen: currentValues.timesSeen + 1,
      lastSeen: new Date(),
      correctCount: isCorrect ? currentValues.correctCount + 1 : currentValues.correctCount,
      incorrectCount: isCorrect ? currentValues.incorrectCount : currentValues.incorrectCount + 1,
      consecutiveCorrect: isCorrect ? currentValues.consecutiveCorrect + 1 : 0,
      // SM-2 fields
      easinessFactor: sm2Result.easinessFactor,
      interval: sm2Result.interval,
      repetition: sm2Result.repetition,
      nextReviewDate: nextReviewDate,
      quality: sm2Result.quality,
      isManuallyLearned: sm2Result.isLearned,
    };

    console.log('Upserting progress with data:', progressData);

    // Use upsert to handle both create and update cases atomically
    const updatedProgress = await prisma.userProgress.upsert({
      where: {
        userId_wordId: {
          userId: userId,
          wordId: wordIdNum,
        },
      },
      update: progressData,
      create: {
        userId: userId,
        wordId: wordIdNum,
        ...progressData,
      },
    });

    console.log('Successfully upserted progress:', updatedProgress.id);

    const wasLearned = sm2Result.isLearned && !currentValues.isManuallyLearned;



    return NextResponse.json({
      ...updatedProgress,
      wasLearned: wasLearned, // New learning in this session
      sm2Info: {
        quality: sm2Result.quality,
        nextReview: sm2Result.nextReviewDate,
        interval: sm2Result.interval,
        repetition: sm2Result.repetition
      }
    });
  } catch (error) {
    console.error('Error updating user progress:', error);
    console.error('Error details:', {
      message: (error as Error).message,
      stack: (error as Error).stack,
      name: (error as Error).name
    });
    return NextResponse.json({
      message: 'Internal server error',
      error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined
    }, { status: 500 });
  }
}